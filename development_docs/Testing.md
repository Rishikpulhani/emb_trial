When we run `cargo test` now, we see that it now succeeds (if it doesn’t, see the note below). However, we still see our “Hello World” instead of the message from our `test_runner`. The reason is that our `_start` function is still used as entry point. The custom test frameworks feature generates a `main` function that calls `test_runner`, but this function is ignored because we use the `#[no_main]` attribute and provide our own entry point.
what cutom_test_framework expects 
start -> main (of test) i.e. start will call main but this never happens because we dont call this main in our start function
but here the main is ignored 
## problem with duplicate langitem 
we use the panic abort in our dev profile but cargo test uses dev profile but also requires its unwinding to work so it inserts its own panic handler - hence to panic impl (duplicate lang items)
and so we need to disable 1 as there can only be 1 panic impl in a program
## renaming and re exporting main 
- normal case - the main of the test is generated by the compiler behind the scenes and in that it takes all the tests and passes them as an arg to the test runner which then executes the tests. this function is generate behind at the time of compilation as  an implementation detail and has the name main which is a symbol used by thge linker to place it in a way to be called by the start func. - all this is called the test harness logic (all this machinery)
- no_std (so custom entry point start) no_main (no main symbol generated) env - here this main function is althouigh generated behind the scenes but the symbol is never exposed as main to the linker and since accroding to the logic of the test harness machinery it assumes that the compiler will automatically place main under start but that doesnt happen here as main is exposed as main - basically the test harness was compiled but not linked 
- solution - to manually call the main function but since it is not pub as generated and used interna;lly we tell the compiler to re export it explicitly
## I/O ports
there are 2 kinds of io supported by the x86 architecture - port mapped and memory mapped 
- port mapped io- this is a seperate syste from the ram and thre are special instructions in the x86 isa to use theses- these are a sepearate address space other than the ram and is only accessbile by special instructions in,out. there are sepearte address usses to communicate with these - the addresses of the port are called the port numbers here - here the data is dorectly sent to the device via the seperate i/o busses and goes directly into the device which processes and gives back the output via the busses 
- memory mapped - in this the devices access points lives in the same ram and there are no sepearate instruction or addresses busses for communivcating with them. - these are portable and faster as can move the devices in the memory and no seperate system to be used - here the devices read and write data to the ram at the specified memory loactions  
## exiting qemu
- QEMU supports a special `isa-debug-exit` device and this is mapped with an i/o port - we need to send and exit code to it in order to exit the qemu - this is a DEVICE which we configure to be at that port on our machine - it gets and sends data at that port via the i/o busses 
- here we used different exit codes than 0 or 1 as the actual exit codes dont matter and not use 0 and 1 because they dont clash with the default exit codes of QEMU
- here the device which we have confiogured is the one which receivesthe exit code and processes it and givces back an action to be preformed which is shut down here. in the processesing The functionality of the `isa-debug-exit` device is very simple. When a `value` is written to the I/O port specified by `iobase`, it causes QEMU to exit with [exit status](https://en.wikipedia.org/wiki/Exit_status) `(value << 1) | 1`. so based on the input exit code it operates on it and gives back an exit code which is diffrent from the qemu ones - this is the reason of that bit shoft and the or 1 so that it wont ineterfere with the default qemu exit codes 
- `cargo test` considers all error codes other than `0` as failure. so we need to specifically map our custoim exit code with 0
- here the exit code of qemu tells whether the tests passed or some failed 
## serial port 
since qemu is emulating an entire machine with its cpu, io devices, ram and everythings so it can also emulkate serial ports - in the back it will be redirecting the data to somewhere else which is here can be set by us to our stdout and so we can print the test resules in our console
we use the uart 16550 chip interface to sed data serially - this chip is emulated by the qemu
the interface of this chip is the manner in which data is to be sent over it 
uart has several ports as it has several device registers to set and each one is responsible for a different thing - these help tomanage th device internally 
## integration tests 
these get built as a different crate sepeartae from the main.rs as these need to check that how are the diufferent segements of the code are to function with each other and these are assumed by the rust suyetem, to be in a lib.rs. these need to be conducted in the same env as our binaray runs which is the no_std env. we cannot just take code from main.rs, also if copy the code from there to create the same environment then it will lead to inconsistence in the testing env and the main env as the code may differ as make changes.
the lib.rs ia also a seperate compilation unit or TARGET than a binary executable like the main.rs or integration tests. lib are reusable as can be imported by other binaris without recompilation as directly called at the time of linking, whereas binaries are not reusable targets as connot be reused in other binaries. 
this is so as in case of lib it has exposed symbols which can be linked with the binaries at the time of linking whereas binaries have their own entry point and are self contained and they dont expose any symbols outside for linking 
the goal here is to implement the same environment in both places the main and in the integrations tests  
in order to run integration tests we need the panic handlers, we need a test runner to run the tests inside the intr=egration tests crate and we also need an entry point to call the main of that integration tests file, here just like the main we need to implement all of these as in case of integration tests w need to same env so we have them in no_std and in no_std we need to implement all of these 
so for them to be same we need the lib.rs to give the panic handler
we also need the entire testing machinery we built to be there, so we need to add the serial port support, so we add it all to lib - so we transfer all the serial port support and the exit of qemu to lib.rs and from there it will be access to bopth the main and the integration tests 
**NOTE : all the functionality implemented in the main like the vga buffer and the entire testing framework and the serial port need to be also given to the integration tests just like the main has it and so we shift all of it to the lib and both the main and the integration test access them from the lib hence giving the same enviroment to both of them. also all the unit testing which needs to be done for the individual components like the serial port and the vga buffer can be done in the lib itself and instead of moving thier code to lib we can just remove them from the mod of the main and make them the module of the lib, and for the rest the code which is oinly in main and is also needed in the integration test executables , that will be copied to lib.rs
but hings like the paninc handler can be only 1 in each executable and so we dont give it from the lib but for unit test in the lib since we form a seperate executable than the integration test one so we can define a panic handler for that configuration
now since no testing will be done of the main and all the code to be tested is in the lib.rs or the integration test so we can move all the testing related code there**
The power of integration tests is that they’re treated as completely separate executables. This gives them complete control over the environment, which makes it possible to test that the code interacts correctly with the CPU or hardware devices.