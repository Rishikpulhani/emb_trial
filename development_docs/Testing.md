When we run `cargo test` now, we see that it now succeeds (if it doesn’t, see the note below). However, we still see our “Hello World” instead of the message from our `test_runner`. The reason is that our `_start` function is still used as entry point. The custom test frameworks feature generates a `main` function that calls `test_runner`, but this function is ignored because we use the `#[no_main]` attribute and provide our own entry point.
what cutom_test_framework expects 
start -> main (of test) i.e. start will call main but this never happens because we dont call this main in our start function
but here the main is ignored 
## problem with duplicate langitem 
we use the panic abort in our dev profile but cargo test uses dev profile but also requires its unwinding to work so it inserts its own panic handler - hence to panic impl (duplicate lang items)
and so we need to disable 1 as there can only be 1 panic impl in a program
## renaming and re exporting main 
- normal case - the main of the test is generated by the compiler behind the scenes and in that it takes all the tests and passes them as an arg to the test runner which then executes the tests. this function is generate behind at the time of compilation as  an implementation detail and has the name main which is a symbol used by thge linker to place it in a way to be called by the start func. - all this is called the test harness logic (all this machinery)
- no_std (so custom entry point start) no_main (no main symbol generated) env - here this main function is althouigh generated behind the scenes but the symbol is never exposed as main to the linker and since accroding to the logic of the test harness machinery it assumes that the compiler will automatically place main under start but that doesnt happen here as main is exposed as main - basically the test harness was compiled but not linked 
- solution - to manually call the main function but since it is not pub as generated and used interna;lly we tell the compiler to re export it explicitly